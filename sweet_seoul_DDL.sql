-- Sweet Seoul Korean Bakery Database Creation Script (Oracle 19c Version)
-- This script creates all tables and constraints for the Sweet Seoul Korean Bakery database

-- First, create sequences for auto-increment functionality
-- but they aren't neccessary since we're using IDENTITY columns for all tables
-- They don't cause any harm, but we could consider removing them to clean up the script further.
CREATE SEQUENCE customers_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE marketing_channels_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE promotions_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE products_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE inventory_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE subscriptions_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE customer_preferences_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE gift_cards_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE orders_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE feedback_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE order_items_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE subscription_items_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE order_status_history_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE product_promotions_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE customer_promotion_seq START WITH 1 INCREMENT BY 1;

-- Drop existing tables if they exist (in reverse order of creation to avoid constraint violations)
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE PRODUCT_PROMOTIONS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE ORDER_STATUS_HISTORY CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE SUBSCRIPTION_ITEMS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE ORDER_ITEMS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE FEEDBACK CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE ORDERS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE GIFT_CARDS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE CUSTOMER_PREFERENCES CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE SUBSCRIPTIONS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE INVENTORY CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE PRODUCTS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE PROMOTIONS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE MARKETING_CHANNELS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE CUSTOMERS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE CUSTOMER_PROMOTION CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

-- Create CUSTOMERS table with GENERATED BY DEFAULT AS IDENTITY instead of NUMBER(10) for customer_id field
CREATE TABLE CUSTOMERS (
    customer_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    email VARCHAR2(100) NOT NULL UNIQUE,
    phone VARCHAR2(20) NOT NULL,
    join_date DATE DEFAULT SYSDATE NOT NULL,
    address VARCHAR2(255) NOT NULL,
    city VARCHAR2(50) NOT NULL,
    state VARCHAR2(50) NOT NULL,
    postal_code VARCHAR2(20) NOT NULL,
    is_online_customer NUMBER(1) DEFAULT 0 NOT NULL,
    is_in_store_customer NUMBER(1) DEFAULT 0 NOT NULL,
    loyalty_points NUMBER(10) DEFAULT 0 NOT NULL,
    loyalty_status VARCHAR2(20) DEFAULT 'Standard' NOT NULL,
    preferred_communication_method VARCHAR2(20) DEFAULT 'Email',
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT chk_loyalty_points CHECK (loyalty_points >= 0),
    CONSTRAINT chk_preferred_comm CHECK (preferred_communication_method IN ('Email', 'SMS', 'Phone', 'Mail'))
);

-- Create index on CUSTOMERS
CREATE INDEX idx_customer_loyalty ON CUSTOMERS(loyalty_status);

-- CREATE INDEX idx_customer_email ON CUSTOMERS(email);
/*
The CUSTOMERS table includes an email column defined as VARCHAR2(100) NOT NULL UNIQUE. 
The UNIQUE constraint on this column automatically creates an index on the email column to enforce uniqueness.
Running this index will produce an ORA-01408 error because Oracle has already created an index on the email column due to the UNIQUE constraint. 
The error message "such column list already indexed" clearly indicates this issue.
*/

-- Create MARKETING_CHANNELS table
CREATE TABLE MARKETING_CHANNELS (
    marketing_channel_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    channel_name VARCHAR2(50) NOT NULL UNIQUE,
    channel_type VARCHAR2(20) NOT NULL,
    specific_platform VARCHAR2(50) NOT NULL,
    customer_acquisition_cost NUMBER(10, 2) DEFAULT 0.00,
    conversion_rate NUMBER(3) DEFAULT 0,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT chk_acquisition_cost CHECK (customer_acquisition_cost >= 0),
    CONSTRAINT chk_conversion_rate CHECK (conversion_rate >= 0 AND conversion_rate <= 100)
);

-- Create index separately
CREATE INDEX idx_marketing_channel_type ON MARKETING_CHANNELS(channel_type);

-- create triggers to automatically update the updated_at column when a row is modified
CREATE OR REPLACE TRIGGER trg_marketing_channels_update
BEFORE UPDATE ON MARKETING_CHANNELS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create PROMOTIONS table
CREATE TABLE PROMOTIONS (
    promotion_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    promotion_name VARCHAR2(100) NOT NULL,
    description CLOB NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    discount_amount NUMBER(10, 2) NOT NULL,
    discount_type VARCHAR2(20) NOT NULL,
    platform VARCHAR2(20) NOT NULL,
    kpop_anime_reference VARCHAR2(100),
    is_gift_card_promo NUMBER(1) DEFAULT 0 NOT NULL,
    promotion_type VARCHAR2(20) NOT NULL,
    min_purchase NUMBER(10, 2) DEFAULT 0.00,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT chk_promotion_dates CHECK (end_date >= start_date),
    CONSTRAINT chk_discount_amount CHECK (discount_amount >= 0),
    CONSTRAINT chk_min_purchase CHECK (min_purchase >= 0),
    CONSTRAINT chk_platform CHECK (platform IN ('online', 'in-store', 'both')),
    CONSTRAINT chk_discount_type CHECK (discount_type IN ('percentage', 'fixed')),
    CONSTRAINT chk_promotion_type CHECK (promotion_type IN ('discount', 'bundle', 'offer', 'gift'))
);

-- Create indexes separately
CREATE INDEX idx_promotion_dates ON PROMOTIONS(start_date, end_date);
CREATE INDEX idx_promotion_platform ON PROMOTIONS(platform);
CREATE INDEX idx_promotion_type ON PROMOTIONS(promotion_type);

-- for the automatic update of the updated_at column, we'll need a trigger
CREATE OR REPLACE TRIGGER trg_promotions_update
BEFORE UPDATE ON PROMOTIONS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create CUSTOMER_PROMOTION table
CREATE TABLE CUSTOMER_PROMOTION (
    customer_promotion_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    customer_id NUMBER NOT NULL,
    promotion_id NUMBER NOT NULL,
    is_used NUMBER(1) DEFAULT 0 NOT NULL,
    date_offered DATE DEFAULT SYSDATE NOT NULL,
    expiry_date DATE NOT NULL,
    times_used NUMBER DEFAULT 0 NOT NULL,
    usage_limit NUMBER DEFAULT 1 NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_cust_promo_customer FOREIGN KEY (customer_id) 
        REFERENCES CUSTOMERS(customer_id) ON DELETE CASCADE,
    CONSTRAINT fk_cust_promo_promotion FOREIGN KEY (promotion_id) 
        REFERENCES PROMOTIONS(promotion_id) ON DELETE CASCADE,
    CONSTRAINT uq_customer_promotion UNIQUE (customer_id, promotion_id),
    CONSTRAINT chk_times_used CHECK (times_used >= 0),
    CONSTRAINT chk_usage_limit CHECK (usage_limit > 0),
    CONSTRAINT chk_expiry_date_valid CHECK (expiry_date >= date_offered)
);

-- Create indexes
CREATE INDEX idx_customer_promotion_used ON CUSTOMER_PROMOTION(is_used);
CREATE INDEX idx_customer_promotion_expiry ON CUSTOMER_PROMOTION(expiry_date);

-- Create trigger for automatic update of updated_at column
CREATE OR REPLACE TRIGGER trg_customer_promotion_update
BEFORE UPDATE ON CUSTOMER_PROMOTION
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create PRODUCTS table
CREATE TABLE PRODUCTS (
    product_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    product_name VARCHAR2(100) NOT NULL UNIQUE,
    description CLOB NOT NULL,
    category VARCHAR2(50) NOT NULL,
    origin VARCHAR2(50) NOT NULL,
    base_price NUMBER(10, 2) NOT NULL,
    seasonal NUMBER(1) DEFAULT 0 NOT NULL,
    expiry_date DATE,
    limited_edition NUMBER(1) DEFAULT 0 NOT NULL,
    kpop_anime_tie_in VARCHAR2(100),
    online_exclusive NUMBER(1) DEFAULT 0 NOT NULL,
    in_store_exclusive NUMBER(1) DEFAULT 0 NOT NULL,
    min_inventory_level NUMBER NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT chk_base_price CHECK (base_price >= 0),
    CONSTRAINT chk_min_inventory CHECK (min_inventory_level >= 0),
    CONSTRAINT chk_exclusivity CHECK (NOT (online_exclusive = 1 AND in_store_exclusive = 1))
);

-- create indexes
CREATE INDEX idx_product_category ON PRODUCTS(category);
CREATE INDEX idx_product_seasonal ON PRODUCTS(seasonal);
CREATE INDEX idx_product_limited ON PRODUCTS(limited_edition);
CREATE INDEX idx_product_kpop ON PRODUCTS(kpop_anime_tie_in);

-- create trigger
CREATE OR REPLACE TRIGGER trg_products_update
BEFORE UPDATE ON PRODUCTS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create INVENTORY table
CREATE TABLE INVENTORY (
    inventory_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    product_id NUMBER NOT NULL UNIQUE,
    current_stock NUMBER DEFAULT 0 NOT NULL,
    reorder_point NUMBER NOT NULL,
    last_restock_date DATE,
    expected_arrival DATE,
    storage_requirements CLOB,
    min_stock_level NUMBER NOT NULL,
    max_stock_level NUMBER NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_inventory_product FOREIGN KEY (product_id) REFERENCES PRODUCTS(product_id) ON DELETE CASCADE,
    CONSTRAINT chk_current_stock CHECK (current_stock >= 0),
    CONSTRAINT chk_reorder_point CHECK (reorder_point >= 0),
    CONSTRAINT chk_min_stock CHECK (min_stock_level >= 0),
    CONSTRAINT chk_max_min_stock CHECK (max_stock_level >= min_stock_level)
);

-- create index 
CREATE INDEX idx_inventory_stock ON INVENTORY(current_stock);

-- create triggers
CREATE OR REPLACE TRIGGER trg_inventory_update
BEFORE UPDATE ON INVENTORY
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create SUBSCRIPTIONS table
CREATE TABLE SUBSCRIPTIONS (
    subscription_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    customer_id NUMBER NOT NULL,
    start_date DATE NOT NULL,
    next_delivery_date DATE NOT NULL,
    subscription_status VARCHAR2(20) DEFAULT 'Active' NOT NULL,
    monthly_price NUMBER(10, 2) NOT NULL,
    billing_cycle NUMBER DEFAULT 1 NOT NULL,
    subscription_type VARCHAR2(20) DEFAULT 'Standard' NOT NULL,
    is_gift NUMBER(1) DEFAULT 0 NOT NULL,
    delivery_address CLOB NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_subscription_customer FOREIGN KEY (customer_id) 
        REFERENCES CUSTOMERS(customer_id) ON DELETE CASCADE,
    CONSTRAINT chk_monthly_price CHECK (monthly_price >= 0),
    CONSTRAINT chk_billing_cycle CHECK (billing_cycle > 0),
    CONSTRAINT chk_subscription_status CHECK (subscription_status IN ('Active', 'Paused', 'Canceled')),
    CONSTRAINT chk_subscription_type CHECK (subscription_type IN ('Standard', 'Premium'))
);

-- create indexes
CREATE INDEX idx_subscription_status ON SUBSCRIPTIONS(subscription_status);
CREATE INDEX idx_subscription_type ON SUBSCRIPTIONS(subscription_type);

-- create trigger
CREATE OR REPLACE TRIGGER trg_subscriptions_update
BEFORE UPDATE ON SUBSCRIPTIONS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create CUSTOMER_PREFERENCES table
CREATE TABLE CUSTOMER_PREFERENCES (
    preference_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    customer_id NUMBER NOT NULL UNIQUE,
    flavor_preference CLOB,
    product_category_preference CLOB,
    subscription_interest NUMBER(1) DEFAULT 0,
    kpop_anime_interest VARCHAR2(255),
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_preference_customer FOREIGN KEY (customer_id) 
        REFERENCES CUSTOMERS(customer_id) ON DELETE CASCADE
);

-- create index
CREATE INDEX idx_preference_subscription ON CUSTOMER_PREFERENCES(subscription_interest);

-- create trigger
CREATE OR REPLACE TRIGGER trg_customer_preferences_update
BEFORE UPDATE ON CUSTOMER_PREFERENCES
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create GIFT_CARDS table
CREATE TABLE GIFT_CARDS (
    gift_card_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    issuer_customer_id NUMBER NOT NULL,
    recipient_customer_id NUMBER,
    gift_card_code VARCHAR2(50) NOT NULL UNIQUE,
    initial_amount NUMBER(10, 2) NOT NULL,
    current_balance NUMBER(10, 2) NOT NULL,
    issue_date DATE DEFAULT SYSDATE NOT NULL,
    expiry_date DATE NOT NULL,
    is_redeemed NUMBER(1) DEFAULT 0 NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_gift_issuer FOREIGN KEY (issuer_customer_id) 
        REFERENCES CUSTOMERS(customer_id),
    CONSTRAINT fk_gift_recipient FOREIGN KEY (recipient_customer_id) 
        REFERENCES CUSTOMERS(customer_id),
    CONSTRAINT chk_initial_amount CHECK (initial_amount > 0),
    CONSTRAINT chk_current_balance CHECK (current_balance >= 0),
    CONSTRAINT chk_balance_limit CHECK (current_balance <= initial_amount),
    CONSTRAINT chk_expiry_date CHECK (expiry_date > issue_date)
);

-- create indexes
CREATE INDEX idx_gift_card_code ON GIFT_CARDS(gift_card_code);
CREATE INDEX idx_gift_card_redeemed ON GIFT_CARDS(is_redeemed);

-- create trigger
CREATE OR REPLACE TRIGGER trg_gift_cards_update
BEFORE UPDATE ON GIFT_CARDS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create ORDERS table
CREATE TABLE ORDERS (
    order_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    customer_id NUMBER NOT NULL,
    order_date DATE DEFAULT SYSDATE NOT NULL,
    total_amount NUMBER(10, 2) NOT NULL,
    order_status VARCHAR2(20) DEFAULT 'Pending' NOT NULL,
    payment_method VARCHAR2(50) NOT NULL,
    marketing_channel_id NUMBER,
    platform VARCHAR2(20) NOT NULL,
    is_gift NUMBER(1) DEFAULT 0 NOT NULL,
    gift_card_id NUMBER,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_order_customer FOREIGN KEY (customer_id) 
        REFERENCES CUSTOMERS(customer_id),
    CONSTRAINT fk_order_marketing FOREIGN KEY (marketing_channel_id) 
        REFERENCES MARKETING_CHANNELS(marketing_channel_id),
    CONSTRAINT fk_order_gift_card FOREIGN KEY (gift_card_id) 
        REFERENCES GIFT_CARDS(gift_card_id),
    CONSTRAINT chk_total_amount CHECK (total_amount >= 0),
    CONSTRAINT chk_order_status CHECK (order_status IN ('Pending', 'Processing', 'Shipped', 'Delivered', 'Canceled')),
    CONSTRAINT chk_order_platform CHECK (platform IN ('online', 'in-store'))
);

-- create indexes
CREATE INDEX idx_order_date ON ORDERS(order_date);
CREATE INDEX idx_order_status ON ORDERS(order_status);
CREATE INDEX idx_order_platform ON ORDERS(platform);

-- create triggers
CREATE OR REPLACE TRIGGER trg_orders_update
BEFORE UPDATE ON ORDERS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create FEEDBACK table incrementally
CREATE TABLE FEEDBACK (
    feedback_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id NUMBER NOT NULL,
    rating NUMBER NOT NULL
);

ALTER TABLE FEEDBACK ADD (
    order_id NUMBER,
    product_id NUMBER,
    feedback_date DATE NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

-- add constraints
ALTER TABLE FEEDBACK ADD CONSTRAINT chk_rating_range 
    CHECK (rating >= 1 AND rating <= 5);
    
ALTER TABLE FEEDBACK ADD CONSTRAINT fk_feedback_customer 
    FOREIGN KEY (customer_id) REFERENCES CUSTOMERS(customer_id);
    
ALTER TABLE FEEDBACK ADD CONSTRAINT fk_feedback_order 
    FOREIGN KEY (order_id) REFERENCES ORDERS(order_id);
    
ALTER TABLE FEEDBACK ADD CONSTRAINT fk_feedback_product 
    FOREIGN KEY (product_id) REFERENCES PRODUCTS(product_id);

-- add triggers
CREATE OR REPLACE TRIGGER trg_feedback_before_insert
BEFORE INSERT ON FEEDBACK
FOR EACH ROW
BEGIN
    IF :NEW.feedback_date IS NULL THEN
        :NEW.feedback_date := SYSDATE;
    END IF;
    
    IF :NEW.created_at IS NULL THEN
        :NEW.created_at := SYSTIMESTAMP;
    END IF;
    
    IF :NEW.updated_at IS NULL THEN
        :NEW.updated_at := SYSTIMESTAMP;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_feedback_update
BEFORE UPDATE ON FEEDBACK
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- add indexes
CREATE INDEX idx_feedback_rating ON FEEDBACK(rating);
CREATE INDEX idx_feedback_date ON FEEDBACK(feedback_date);

-- create ORDER_ITEMS table
CREATE TABLE ORDER_ITEMS (
    order_item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id NUMBER NOT NULL,
    product_id NUMBER NOT NULL,
    quantity NUMBER NOT NULL,
    unit_price NUMBER(10, 2) NOT NULL,
    discount NUMBER(10, 2) DEFAULT 0.00,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

-- add constraints
ALTER TABLE ORDER_ITEMS ADD CONSTRAINT fk_order_item_order
    FOREIGN KEY (order_id) REFERENCES ORDERS(order_id) ON DELETE CASCADE;
    
ALTER TABLE ORDER_ITEMS ADD CONSTRAINT fk_order_item_product
    FOREIGN KEY (product_id) REFERENCES PRODUCTS(product_id);
    
ALTER TABLE ORDER_ITEMS ADD CONSTRAINT chk_quantity
    CHECK (quantity > 0);
    
ALTER TABLE ORDER_ITEMS ADD CONSTRAINT chk_unit_price
    CHECK (unit_price >= 0);
    
ALTER TABLE ORDER_ITEMS ADD CONSTRAINT chk_discount
    CHECK (discount >= 0);
    
ALTER TABLE ORDER_ITEMS ADD CONSTRAINT chk_discount_limit
    CHECK (discount <= unit_price * quantity);

-- add index
CREATE INDEX idx_order_item_product ON ORDER_ITEMS(product_id);

-- create triggers
CREATE OR REPLACE TRIGGER trg_order_items_before_insert
BEFORE INSERT ON ORDER_ITEMS
FOR EACH ROW
BEGIN
    IF :NEW.created_at IS NULL THEN
        :NEW.created_at := SYSTIMESTAMP;
    END IF;
    
    IF :NEW.updated_at IS NULL THEN
        :NEW.updated_at := SYSTIMESTAMP;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_order_items_update
BEFORE UPDATE ON ORDER_ITEMS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create SUBSCRIPTION_ITEMS table
CREATE TABLE SUBSCRIPTION_ITEMS (
    subscription_item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    subscription_id NUMBER NOT NULL,
    product_id NUMBER NOT NULL,
    month NUMBER NOT NULL,
    year NUMBER NOT NULL,
    quantity NUMBER DEFAULT 1 NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

-- add constraints
ALTER TABLE SUBSCRIPTION_ITEMS ADD CONSTRAINT fk_sub_item_subscription
    FOREIGN KEY (subscription_id) REFERENCES SUBSCRIPTIONS(subscription_id) ON DELETE CASCADE;
    
ALTER TABLE SUBSCRIPTION_ITEMS ADD CONSTRAINT fk_sub_item_product
    FOREIGN KEY (product_id) REFERENCES PRODUCTS(product_id);
    
ALTER TABLE SUBSCRIPTION_ITEMS ADD CONSTRAINT uq_sub_product_month_year
    UNIQUE (subscription_id, product_id, month, year);
    
ALTER TABLE SUBSCRIPTION_ITEMS ADD CONSTRAINT chk_month_range
    CHECK (month >= 1 AND month <= 12);
    
ALTER TABLE SUBSCRIPTION_ITEMS ADD CONSTRAINT chk_year_min
    CHECK (year >= 2023);
    
ALTER TABLE SUBSCRIPTION_ITEMS ADD CONSTRAINT chk_quantity_positive
    CHECK (quantity > 0);

-- create index
CREATE INDEX idx_subscription_item_date ON SUBSCRIPTION_ITEMS(year, month);

-- create triggers
CREATE OR REPLACE TRIGGER trg_sub_items_before_insert
BEFORE INSERT ON SUBSCRIPTION_ITEMS
FOR EACH ROW
BEGIN
    IF :NEW.created_at IS NULL THEN
        :NEW.created_at := SYSTIMESTAMP;
    END IF;
    
    IF :NEW.updated_at IS NULL THEN
        :NEW.updated_at := SYSTIMESTAMP;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_sub_items_update
BEFORE UPDATE ON SUBSCRIPTION_ITEMS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create ORDER_STATUS_HISTORY table
CREATE TABLE ORDER_STATUS_HISTORY (
    history_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id NUMBER NOT NULL,
    previous_status VARCHAR2(20) NOT NULL,
    new_status VARCHAR2(20) NOT NULL,
    status_change_date TIMESTAMP NOT NULL,
    updated_by VARCHAR2(50) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

-- add foreign key constraint
ALTER TABLE ORDER_STATUS_HISTORY ADD CONSTRAINT fk_hist_order
    FOREIGN KEY (order_id) REFERENCES ORDERS(order_id) ON DELETE CASCADE;

-- add check constraints 
ALTER TABLE ORDER_STATUS_HISTORY ADD CONSTRAINT chk_prev_status
    CHECK (previous_status IN ('Pending', 'Processing', 'Shipped', 'Delivered', 'Canceled'));
    
ALTER TABLE ORDER_STATUS_HISTORY ADD CONSTRAINT chk_new_status
    CHECK (new_status IN ('Pending', 'Processing', 'Shipped', 'Delivered', 'Canceled'));

-- create indexes
CREATE INDEX idx_history_order ON ORDER_STATUS_HISTORY(order_id);
CREATE INDEX idx_history_status ON ORDER_STATUS_HISTORY(new_status);

-- add trigger for timestamp defaults
CREATE OR REPLACE TRIGGER trg_order_hist_before_insert
BEFORE INSERT ON ORDER_STATUS_HISTORY
FOR EACH ROW
BEGIN
    IF :NEW.status_change_date IS NULL THEN
        :NEW.status_change_date := SYSTIMESTAMP;
    END IF;
    
    IF :NEW.created_at IS NULL THEN
        :NEW.created_at := SYSTIMESTAMP;
    END IF;
    
    IF :NEW.updated_at IS NULL THEN
        :NEW.updated_at := SYSTIMESTAMP;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_order_hist_update
BEFORE UPDATE ON ORDER_STATUS_HISTORY
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- create PRODUCT_PROMOTIONS table
CREATE TABLE PRODUCT_PROMOTIONS (
    product_promotion_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_id NUMBER NOT NULL,
    promotion_id NUMBER NOT NULL,
    special_price NUMBER(10, 2),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

-- add constraints
ALTER TABLE PRODUCT_PROMOTIONS ADD CONSTRAINT fk_prod_promo_product
    FOREIGN KEY (product_id) REFERENCES PRODUCTS(product_id) ON DELETE CASCADE;
    
ALTER TABLE PRODUCT_PROMOTIONS ADD CONSTRAINT fk_prod_promo_promotion
    FOREIGN KEY (promotion_id) REFERENCES PROMOTIONS(promotion_id) ON DELETE CASCADE;
    
ALTER TABLE PRODUCT_PROMOTIONS ADD CONSTRAINT uq_product_promotion
    UNIQUE (product_id, promotion_id);
    
ALTER TABLE PRODUCT_PROMOTIONS ADD CONSTRAINT chk_special_price
    CHECK (special_price IS NULL OR special_price >= 0);

-- add triggers
CREATE OR REPLACE TRIGGER trg_prod_promo_before_insert
BEFORE INSERT ON PRODUCT_PROMOTIONS
FOR EACH ROW
BEGIN
    IF :NEW.created_at IS NULL THEN
        :NEW.created_at := SYSTIMESTAMP;
    END IF;
    
    IF :NEW.updated_at IS NULL THEN
        :NEW.updated_at := SYSTIMESTAMP;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_prod_promo_update
BEFORE UPDATE ON PRODUCT_PROMOTIONS
FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/





/***********************************************************************************************************
ALL TABLES SHOULD BE CREATED AT THIS POINT !!!!!!! QUICK CONFIRMATION TEST BELOW
***********************************************************************************************************/

-- check that all the tables were created
SELECT table_name FROM user_tables ORDER BY table_name;

/***********************************************************************************************************
BEGIN IMPLEMENTING BUSINESS LOGIC
***********************************************************************************************************/

/*
We'll need additional triggers to implement the business logic
*/

-- Add triggers for auto-updating ORDER_STATUS_HISTORY when ORDERS.order_status changes
CREATE OR REPLACE TRIGGER before_order_status_update
BEFORE UPDATE ON ORDERS
FOR EACH ROW
BEGIN
    IF :OLD.order_status != :NEW.order_status THEN
        INSERT INTO ORDER_STATUS_HISTORY (order_id, previous_status, new_status, updated_by, status_change_date, created_at, updated_at)
        VALUES (:OLD.order_id, :OLD.order_status, :NEW.order_status, USER, SYSTIMESTAMP, SYSTIMESTAMP, SYSTIMESTAMP);
    END IF;
END;
/

-- Add trigger for initial status record when order is created
CREATE OR REPLACE TRIGGER after_order_insert
AFTER INSERT ON ORDERS
FOR EACH ROW
BEGIN
    INSERT INTO ORDER_STATUS_HISTORY (order_id, previous_status, new_status, updated_by, status_change_date, created_at, updated_at)
    VALUES (:NEW.order_id, 'Created', :NEW.order_status, USER, SYSTIMESTAMP, SYSTIMESTAMP, SYSTIMESTAMP);
END;
/

-- Add trigger to update inventory when order items are added
CREATE OR REPLACE TRIGGER after_order_item_insert
AFTER INSERT ON ORDER_ITEMS
FOR EACH ROW
BEGIN
    UPDATE INVENTORY
    SET current_stock = current_stock - :NEW.quantity
    WHERE product_id = :NEW.product_id;
END;
/

-- Add trigger to update inventory when order items are modified
CREATE OR REPLACE TRIGGER after_order_item_update
AFTER UPDATE ON ORDER_ITEMS
FOR EACH ROW
BEGIN
    UPDATE INVENTORY
    SET current_stock = current_stock + :OLD.quantity - :NEW.quantity
    WHERE product_id = :NEW.product_id;
END;
/

-- Add trigger to update inventory when order items are deleted
CREATE OR REPLACE TRIGGER after_order_item_delete
AFTER DELETE ON ORDER_ITEMS
FOR EACH ROW
BEGIN
    UPDATE INVENTORY
    SET current_stock = current_stock + :OLD.quantity
    WHERE product_id = :OLD.product_id;
END;
/

-- Add trigger to update gift card balance when used in an order
CREATE OR REPLACE TRIGGER after_order_with_gift_card
AFTER INSERT ON ORDERS
FOR EACH ROW
BEGIN
    IF :NEW.gift_card_id IS NOT NULL THEN
        UPDATE GIFT_CARDS
        SET current_balance = current_balance - :NEW.total_amount,
            is_redeemed = CASE WHEN current_balance - :NEW.total_amount <= 0 THEN 1 ELSE is_redeemed END
        WHERE gift_card_id = :NEW.gift_card_id;
    END IF;
END;
/


/***********************************************************************************************************
Create views for common reporting needs
***********************************************************************************************************/

-- Customer order history with totals
CREATE OR REPLACE VIEW vw_customer_order_history AS
SELECT 
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    COUNT(o.order_id) AS total_orders,
    SUM(o.total_amount) AS lifetime_spend,
    MAX(o.order_date) AS last_order_date,
    c.loyalty_points,
    c.loyalty_status
FROM CUSTOMERS c
LEFT JOIN ORDERS o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name, c.email, c.loyalty_points, c.loyalty_status;

-- Product sales performance
CREATE OR REPLACE VIEW vw_product_sales AS
SELECT 
    p.product_id,
    p.product_name,
    p.category,
    p.base_price,
    SUM(oi.quantity) AS total_units_sold,
    SUM(oi.quantity * oi.unit_price) AS total_revenue,
    COUNT(DISTINCT o.order_id) AS order_count,
    AVG(f.rating) AS average_rating
FROM PRODUCTS p
LEFT JOIN ORDER_ITEMS oi ON p.product_id = oi.product_id
LEFT JOIN ORDERS o ON oi.order_id = o.order_id
LEFT JOIN FEEDBACK f ON p.product_id = f.product_id
GROUP BY p.product_id, p.product_name, p.category, p.base_price;

-- Marketing channel effectiveness
CREATE OR REPLACE VIEW vw_marketing_channel_performance AS
SELECT 
    mc.marketing_channel_id,
    mc.channel_name,
    mc.channel_type,
    mc.specific_platform,
    COUNT(o.order_id) AS attributed_orders,
    SUM(o.total_amount) AS total_revenue,
    mc.customer_acquisition_cost,
    CASE 
        WHEN COUNT(o.order_id) > 0 THEN SUM(o.total_amount) / COUNT(o.order_id)
        ELSE 0 
    END AS average_order_value,
    CASE 
        WHEN COUNT(o.order_id) > 0 AND SUM(o.total_amount) > 0 THEN 
            mc.customer_acquisition_cost / (SUM(o.total_amount) / COUNT(o.order_id))
        ELSE 0 
    END AS cac_to_aov_ratio
FROM MARKETING_CHANNELS mc
LEFT JOIN ORDERS o ON mc.marketing_channel_id = o.marketing_channel_id
GROUP BY mc.marketing_channel_id, mc.channel_name, mc.channel_type, mc.specific_platform, mc.customer_acquisition_cost;

-- Subscription performance and retention
CREATE OR REPLACE VIEW vw_subscription_performance AS
SELECT 
    s.subscription_type,
    COUNT(DISTINCT s.subscription_id) AS active_subscriptions,
    AVG(s.monthly_price) AS average_monthly_price,
    SUM(s.monthly_price) AS monthly_recurring_revenue,
    COUNT(DISTINCT CASE WHEN s.subscription_status = 'Canceled' THEN s.subscription_id END) AS canceled_subscriptions,
    CASE 
        WHEN COUNT(DISTINCT s.subscription_id) > 0 
        THEN 1 - (COUNT(DISTINCT CASE WHEN s.subscription_status = 'Canceled' THEN s.subscription_id END) / 
                  NULLIF(COUNT(DISTINCT s.subscription_id), 0))
        ELSE 0 
    END AS retention_rate
FROM SUBSCRIPTIONS s
GROUP BY s.subscription_type;

-- Inventory status and alerts
CREATE OR REPLACE VIEW vw_inventory_alerts AS
SELECT 
    p.product_id,
    p.product_name,
    i.current_stock,
    i.reorder_point,
    i.min_stock_level,
    i.max_stock_level,
    i.last_restock_date,
    i.expected_arrival,
    CASE 
        WHEN i.current_stock <= i.min_stock_level THEN 'Critical'
        WHEN i.current_stock <= i.reorder_point THEN 'Reorder'
        WHEN i.current_stock >= i.max_stock_level * 0.9 THEN 'Overstocked'
        ELSE 'Normal' 
    END AS stock_status
FROM INVENTORY i
JOIN PRODUCTS p ON i.product_id = p.product_id;

-- K-pop/anime product performance
CREATE OR REPLACE VIEW vw_kpop_anime_performance AS
SELECT 
    p.product_id,
    p.product_name,
    p.kpop_anime_tie_in,
    p.limited_edition,
    SUM(oi.quantity) AS total_units_sold,
    SUM(oi.quantity * oi.unit_price) AS total_revenue,
    COUNT(DISTINCT o.order_id) AS order_count,
    AVG(f.rating) AS average_rating
FROM PRODUCTS p
LEFT JOIN ORDER_ITEMS oi ON p.product_id = oi.product_id
LEFT JOIN ORDERS o ON oi.order_id = o.order_id
LEFT JOIN FEEDBACK f ON p.product_id = f.product_id
WHERE p.kpop_anime_tie_in IS NOT NULL
GROUP BY p.product_id, p.product_name, p.kpop_anime_tie_in, p.limited_edition;

-- Gift card usage statistics
CREATE OR REPLACE VIEW vw_gift_card_statistics AS
SELECT 
    COUNT(gc.gift_card_id) AS total_gift_cards,
    SUM(gc.initial_amount) AS total_initial_value,
    SUM(gc.current_balance) AS total_remaining_balance,
    SUM(gc.initial_amount - gc.current_balance) AS total_redeemed_value,
    CASE 
        WHEN SUM(gc.initial_amount) > 0 
        THEN (SUM(gc.initial_amount) - SUM(gc.current_balance)) / NULLIF(SUM(gc.initial_amount), 0)
        ELSE 0 
    END AS redemption_rate,
    COUNT(CASE WHEN gc.is_redeemed = 1 THEN 1 END) AS fully_redeemed_cards,
    COUNT(CASE WHEN gc.current_balance > 0 AND gc.current_balance < gc.initial_amount THEN 1 END) AS partially_redeemed_cards,
    COUNT(CASE WHEN gc.current_balance = gc.initial_amount THEN 1 END) AS unused_cards
FROM GIFT_CARDS gc;

-- Customer feedback summary
CREATE OR REPLACE VIEW vw_customer_feedback_summary AS
SELECT 
    AVG(f.rating) AS average_rating,
    COUNT(f.feedback_id) AS total_feedback,
    COUNT(CASE WHEN f.rating = 5 THEN 1 END) AS five_star_count,
    COUNT(CASE WHEN f.rating = 4 THEN 1 END) AS four_star_count,
    COUNT(CASE WHEN f.rating = 3 THEN 1 END) AS three_star_count,
    COUNT(CASE WHEN f.rating = 2 THEN 1 END) AS two_star_count,
    COUNT(CASE WHEN f.rating = 1 THEN 1 END) AS one_star_count,
    CASE 
        WHEN COUNT(f.feedback_id) > 0 
        THEN (COUNT(CASE WHEN f.rating >= 4 THEN 1 END) * 100.0) / NULLIF(COUNT(f.feedback_id), 0)
        ELSE 0 
    END AS satisfaction_percentage
FROM FEEDBACK f;


-- Create a view for active customer promotions
CREATE OR REPLACE VIEW vw_active_customer_promotions AS
SELECT 
    cp.customer_promotion_id,
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    p.promotion_id,
    p.promotion_name,
    p.discount_amount,
    p.discount_type,
    p.promotion_type,
    cp.is_used,
    cp.date_offered,
    cp.expiry_date,
    cp.times_used,
    cp.usage_limit,
    CASE 
        WHEN cp.expiry_date < SYSDATE THEN 'Expired'
        WHEN cp.times_used >= cp.usage_limit THEN 'Usage Limit Reached'
        WHEN cp.is_used = 1 THEN 'Used'
        ELSE 'Active' 
    END AS status
FROM CUSTOMER_PROMOTION cp
JOIN CUSTOMERS c ON cp.customer_id = c.customer_id
JOIN PROMOTIONS p ON cp.promotion_id = p.promotion_id
WHERE cp.expiry_date >= SYSDATE 
  AND (cp.times_used < cp.usage_limit OR cp.usage_limit = 0);

-- Add customer promotion metrics to reporting views
CREATE OR REPLACE VIEW vw_promotion_usage_statistics AS
SELECT 
    p.promotion_id,
    p.promotion_name,
    p.promotion_type,
    p.discount_type,
    p.discount_amount,
    COUNT(cp.customer_promotion_id) AS total_assignments,
    COUNT(CASE WHEN cp.is_used = 1 THEN 1 END) AS used_count,
    COUNT(CASE WHEN cp.expiry_date < SYSDATE AND cp.is_used = 0 THEN 1 END) AS expired_unused_count,
    CASE 
        WHEN COUNT(cp.customer_promotion_id) > 0 
        THEN (COUNT(CASE WHEN cp.is_used = 1 THEN 1 END) * 100.0) / NULLIF(COUNT(cp.customer_promotion_id), 0)
        ELSE 0 
    END AS usage_percentage
FROM PROMOTIONS p
LEFT JOIN CUSTOMER_PROMOTION cp ON p.promotion_id = cp.promotion_id
GROUP BY p.promotion_id, p.promotion_name, p.promotion_type, p.discount_type, p.discount_amount;

-- Add customer promotion trigger to update is_used flag if usage limit is reached
CREATE OR REPLACE TRIGGER trg_customer_promotion_usage
BEFORE UPDATE OF times_used ON CUSTOMER_PROMOTION
FOR EACH ROW
BEGIN
    IF :NEW.times_used >= :NEW.usage_limit AND :NEW.usage_limit > 0 THEN
        :NEW.is_used := 1;
    END IF;
END;
/